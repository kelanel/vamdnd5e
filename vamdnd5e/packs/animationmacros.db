{"name":"ParsedAnimation-Auto-KO","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/unconscious.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens.\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n//adjust this to match the filtered animations tied to character image of selected tokens\nlet searchstart = \"Idle\"\nlet searchanim = \"Death\"\nlet searchstatic = \"Dead\"\nlet timeoutoffset = 0\n//all other comments afterward are just descriptive for others to understand.\n//\n//simple function for delay timer.\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\nlet defeated = canvas.tokens.placeables.filter(t => {\n\t/* only keep tokens with idle token and HP <=0 a.k.a dead */\n\treturn t.document.actor.data.data?.attributes?.hp?.value <= 0 && t.data.img.search(searchstart) >= 0 \n});\nfor(let nextToken of defeated) {\n\ttry { //exception handling\n\t\t\t\n\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n\t\tif (!originalimg || originalimg === \"\") {\n\t\t\toriginalimg = nextToken.data.img; //backup current image for later.\n\t\t\tconsole.log(\"flag not set for originalimg. Setting now to: \" + originalimg);\n\t\t\tawait nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t}\n\t} catch (err) { //ui catch\n\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t}\n}\nif(defeated.length == 1){\n\t//loop through all selected tokens.\n\tfor(let nextToken of defeated) {\n\t\t(async () => {\n\t\t\ttry { //exception handling\n\t\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n\t\t\t\t\n\t\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\t\tlet StaticArray = []; //predeclare array to load up.\n\t\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\t\tlet search1 = fname.search(searchanim);\n\t\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\t\tlet search3 = fname.search(searchstatic)\n\t\t\t\t\tif (search1 >= 0 && search2 >= 0) { //charname and search name must match to continue\n\t\t\n\t\t\t\t\t\tconsole.log(\"Image found: \" + fname);\n\t\t\t\t\t\tlet sstring = fname.split(\"_\"); //pull framecount\n\t\t\t\t\t\tlet framecount = sstring[sstring.length - 1].split(\"-\")[1]\n\t\t\t\t\t\tlet parsedtimeout = parseFloat( framecount.split(\".\")[0]) //parse framecount into number\n\t\t\t\t\t\tif (isNaN(parsedtimeout)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tconsole.log(\"could not parse animation time due to missing time code!\"); //failed to parse\n\t\t\t\t   \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tconsole.log(\"Expected animation time: \" + parsedtimeout * 33.33 + \"ms\");\n\t\t\t\t\t\t\tlet ParsedAnim = {  //build successfully found animation and add to list of valid animations\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tpath: imagefile,\n\t\t\t\t\t\t\t\ttimeout: (parsedtimeout * 33.33)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tAnimArray.push(ParsedAnim);\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t}else if (search3 >= 0 && search2 >= 0) {\n\t\t\t\t\t\tconsole.log(\"Static Image found: \" + fname);\n\t\t\t\t\t\tStaticArray.push(imagefile);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (AnimArray.length > 1 && StaticArray.length > 0) { //multiple animations, pick one randomly\n\t\t\t\t\tconsole.log(\"Multiple matches found, selecting a random animation\");\n\t\t\t\t\tlet imageChoice = Math.floor(Math.random() * AnimArray.length);\n\t\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t\tlet finalimage = StaticArray[0]\n\t\t\t\t\t//console.log(image);\n\t\t\t\t\tconsole.log(\"Assigning randomized Animation Path: \" + image.path );\n\t\t\t\t\t\n\t\t\t\t\tawait nextToken.document.update({ \"img\": image.path })\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\t\tawait wait((image.timeout + timeoutoffset));\n\t\t\t\t\tconsole.log(\"Animation complete, Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t\t\n\t\t\t\t} else if (AnimArray.length == 1 && StaticArray.length > 0) { // single animation found, no randomization\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlet imageChoice = 0;\n\t\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t\tlet finalimage = StaticArray[0]\n\t\t\t\t\t//console.log(image);\n\t\t\t\t\tconsole.log(\"Single match found. Assigning Animation Path:\" + image.path );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": AnimArray[imageChoice].path })\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + (image.timeout + timeoutoffset) + \" ms\");\n\t\t\t\t\tawait wait((image.timeout + timeoutoffset));\n\t\t\t\t\tconsole.log(\"Animation complete, Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t} else if (AnimArray.length == 0 && StaticArray.length > 0) { // single animation found, no randomization\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlet finalimage = StaticArray[0]\n\t\t\t\t\t//console.log(image);\n\t\t\t\t\t\n\t\t\t\t\tconsole.log(\"No Animation found, Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t} else { //no animation + static picture combo found\n\t\t\t\t\tconsole.log(\"No matching image combinations found for \" + nextToken.name +\", skipping.\");\n\t\t\t\t}\n\t\t\t} catch (err) { //ui catch\n\t\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t}\n\t\t//end of loop. next token\n\t\t})();\n\t}\n}else {//multiple targets, using static only.\n\t\n        for(let nextToken of defeated) {\n        \n\t\t\ttry { //exception handling\n\t\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n    \t\t\t\n\t\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\t\tlet StaticArray = []; //predeclare array to load up.\n\t\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\t\t//let search1 = fname.search(searchanim);\n\t\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\t\tlet search3 = fname.search(searchstatic)\n\t\t\t\t\tif (search3 >= 0 && search2 >= 0) {\n\t\t\t\t\t\tconsole.log(\"Static Image found: \" + fname);\n\t\t\t\t\t\tStaticArray.push(imagefile);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( StaticArray.length > 0) { // single animation found, no randomization\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tlet finalimage = StaticArray[0]\n\t\t\t\t\tconsole.log(\"Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t} else { //no animation + static picture combo found\n\t\t\t\t\tconsole.log(\"No matching image combinations found for \" + nextToken.name +\", skipping.\");\n\t\t\t\t}\n\t\t\t} catch (err) { //ui catch\n\t\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t}\n\t\t\t//end of loop. next token\n\t\t\n             }\n   \n}","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"combat-utility-belt":{"macroTrigger":"nmpygwtqkfh1qnnm"},"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.vRe2nHc2QHxEB8Gc"}},"_id":"1FTBVhEKpkqpPuOn"}
{"name":"ParsedAnimation-Attack","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/sword.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens. V8+ of foundry use only due to new API Controls\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n//adjust this to match the filtered animations tied to character image of selected tokens\nlet search = \"Attack\"\n\n//all other comments afterward are just descriptive for others to understand.\n//\n//simple function for delay timer.\n\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n\n//loop through all selected tokens.\nfor(let nextToken of canvas.tokens.controlled) {\n\t\n\t(async () => {\n\t\ttry { //exception handling\n\t\t\t//let originalimg = nextToken.data.img; //backup current image for later.\n\t\t\t//await nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n        \tif (!originalimg || originalimg === \"\") {\n        \t\toriginalimg = nextToken.data.img; //backup current image for later.\n        \t\tconsole.log(\"flag not set for originalimg. Setting now to: \" + originalimg);\n        \t\tawait nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n        \t}\n        \t\n\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\tlet search1 = fname.search(search);\n\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\tif (search1 >= 0 && search2 >= 0) { //charname and search name must match to continue\n\t\n\t\t\t\t\tconsole.log(\"Image found: \" + fname);\n\t\t\t\t\tlet sstring = fname.split(\"_\"); //pull framecount\n\t\t\t\t\tlet framecount = sstring[sstring.length - 1].split(\"-\")[1]\n\t\t\t\t\tlet parsedtimeout = parseFloat( framecount.split(\".\")[0]) //parse framecount into number\n\t\t\t\t\tif (isNaN(parsedtimeout)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log(\"could not parse animation time due to missing time code!\"); //failed to parse\n\t\t\t   \n\t\t\t\t\t}\n\t\t\t\t\telse { \n\t\t\t\t\t\tconsole.log(\"Expected animation time: \" + parsedtimeout * 33.33 + \"ms\");\n\t\t\t\t\t\tlet ParsedAnim = {  //build successfully found animation and add to list of valid animations\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tpath: imagefile,\n\t\t\t\t\t\t\ttimeout: (parsedtimeout * 33.33)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tAnimArray.push(ParsedAnim);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (AnimArray.length > 1) { //multiple animations, pick one randomly\n\t\n\t\t\t\tconsole.log(\"Multiple matches found, selecting a random animation\");\n\t\t\t\tlet imageChoice = Math.floor(Math.random() * AnimArray.length);\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Assigning randomized Animation Path: \" + image.path );\n\t\t\t\tnextToken.document.update({ \"img\": image.path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\n\t\t\t} else if (AnimArray.length == 1) { // single animation found, no randomization\n\t\t\t\n\t\t\t\t\n\t\t\t\tlet imageChoice = 0;\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Single match found. Assigning Animation Path:\" + image.path );\n\t\t\t\t\n\t\t\t\tnextToken.document.update({ \"img\": AnimArray[imageChoice].path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\t\t   \n\t\t\t} else { //no animations found\n\t\t\t\tui.notifications.warn(\"No matching images found with timecodes for \" + nextToken.name +\"!\");\n\t\t\t}\n\t\t} catch (err) { //ui catch\n\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t}\n\t\t//end of loop. next token\n\t})();\n}","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"furnace":{"runAsGM":false},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.zJM9nLdWiPjULHZg"}},"_id":"1c5dEXLhV4rPZN3G"}
{"name":"ParsedAnimation-Attack1","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/sword.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens. V8+ of foundry use only due to new API Controls\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n//adjust this to match the filtered animations tied to character image of selected tokens\nlet search = \"Attack1\"\n\n//all other comments afterward are just descriptive for others to understand.\n//\n//simple function for delay timer.\n\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n\n//loop through all selected tokens.\nfor(let nextToken of canvas.tokens.controlled) {\n\t\n\t(async () => {\n\t\ttry { //exception handling\n\t\t\t//let originalimg = nextToken.data.img; //backup current image for later.\n\t\t\t//await nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n        \tif (!originalimg || originalimg === \"\") {\n        \t\toriginalimg = nextToken.data.img; //backup current image for later.\n        \t\tconsole.log(\"flag not set for originalimg. Setting now to: \" + originalimg);\n        \t\tawait nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n        \t}\n        \t\n\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\tlet search1 = fname.search(search);\n\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\tif (search1 >= 0 && search2 >= 0) { //charname and search name must match to continue\n\t\n\t\t\t\t\tconsole.log(\"Image found: \" + fname);\n\t\t\t\t\tlet sstring = fname.split(\"_\"); //pull framecount\n\t\t\t\t\tlet framecount = sstring[sstring.length - 1].split(\"-\")[1]\n\t\t\t\t\tlet parsedtimeout = parseFloat( framecount.split(\".\")[0]) //parse framecount into number\n\t\t\t\t\tif (isNaN(parsedtimeout)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log(\"could not parse animation time due to missing time code!\"); //failed to parse\n\t\t\t   \n\t\t\t\t\t}\n\t\t\t\t\telse { \n\t\t\t\t\t\tconsole.log(\"Expected animation time: \" + parsedtimeout * 33.33 + \"ms\");\n\t\t\t\t\t\tlet ParsedAnim = {  //build successfully found animation and add to list of valid animations\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tpath: imagefile,\n\t\t\t\t\t\t\ttimeout: (parsedtimeout * 33.33)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tAnimArray.push(ParsedAnim);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (AnimArray.length > 1) { //multiple animations, pick one randomly\n\t\n\t\t\t\tconsole.log(\"Multiple matches found, selecting a random animation\");\n\t\t\t\tlet imageChoice = Math.floor(Math.random() * AnimArray.length);\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Assigning randomized Animation Path: \" + image.path );\n\t\t\t\tnextToken.document.update({ \"img\": image.path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\n\t\t\t} else if (AnimArray.length == 1) { // single animation found, no randomization\n\t\t\t\n\t\t\t\t\n\t\t\t\tlet imageChoice = 0;\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Single match found. Assigning Animation Path:\" + image.path );\n\t\t\t\t\n\t\t\t\tnextToken.document.update({ \"img\": AnimArray[imageChoice].path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\t\t   \n\t\t\t} else { //no animations found\n\t\t\t\tui.notifications.warn(\"No matching images found with timecodes for \" + nextToken.name +\"!\");\n\t\t\t}\n\t\t} catch (err) { //ui catch\n\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t}\n\t\t//end of loop. next token\n\t})();\n}","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"furnace":{"runAsGM":false},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.ttYCZVlAOSF9YonE"}},"_id":"T3HQf1NE9BtGLi15"}
{"name":"ParsedAnimation-Attack3","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/sword.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens.\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n//adjust this to match the filtered animations tied to character image of selected tokens\nlet search = \"Attack3\"\n\n//all other comments afterward are just descriptive for others to understand.\n//\n//simple function for delay timer.\n\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n\n//cycle through and set default image per token\nfor(let nextToken of canvas.tokens.controlled) {\n\ttry { //exception handling\n\t\t\t\n\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n\t\tif (!originalimg || originalimg === \"\") {\n\t\t\toriginalimg = nextToken.data.img; //backup current image for later.\n\t\t\tconsole.log(\"flag not set for originalimg. Setting now to: \" + originalimg);\n\t\t\tawait nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t}\n\t} catch (err) { //ui catch\n\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t}\n}\n//loop through all selected tokens.\n(async () => {\nfor(let nextToken of canvas.tokens.controlled) {\n\t\n\t\n\t\ttry { //exception handling\n\t\t\t\n\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n        \t\n        \t\n\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\tlet search1 = fname.search(search);\n\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\tif (search1 >= 0 && search2 >= 0) { //charname and search name must match to continue\n\t\n\t\t\t\t\tconsole.log(\"Image found: \" + fname);\n\t\t\t\t\tlet sstring = fname.split(\"_\"); //pull framecount\n\t\t\t\t\tlet framecount = sstring[sstring.length - 1].split(\"-\")[1]\n\t\t\t\t\tlet parsedtimeout = parseFloat( framecount.split(\".\")[0]) //parse framecount into number\n\t\t\t\t\tif (isNaN(parsedtimeout)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log(\"could not parse animation time due to missing time code!\"); //failed to parse\n\t\t\t   \n\t\t\t\t\t}\n\t\t\t\t\telse { \n\t\t\t\t\t\tconsole.log(\"Expected animation time: \" + parsedtimeout * 33.33 + \"ms\");\n\t\t\t\t\t\tlet ParsedAnim = {  //build successfully found animation and add to list of valid animations\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tpath: imagefile,\n\t\t\t\t\t\t\ttimeout: (parsedtimeout * 33.33)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tAnimArray.push(ParsedAnim);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (AnimArray.length > 1) { //multiple animations, pick one randomly\n\t\n\t\t\t\tconsole.log(\"Multiple matches found, selecting a random animation\");\n\t\t\t\tlet imageChoice = Math.floor(Math.random() * AnimArray.length);\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Assigning randomized Animation Path: \" + image.path );\n\t\t\t\tawait nextToken.document.update({ \"img\": image.path })\n\t\t\t\t//await nextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tawait nextToken.document.update({ \"img\": originalimg });\n\t\t\t\t//await nextToken.refresh();\n\t\n\t\t\t} else if (AnimArray.length == 1) { // single animation found, no randomization\n\t\t\t\n\t\t\t\t\n\t\t\t\tlet imageChoice = 0;\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Single match found. Assigning Animation Path:\" + image.path );\n\t\t\t\t\n\t\t\t\tawait nextToken.document.update({ \"img\": AnimArray[imageChoice].path })\n\t\t\t\t//await nextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tawait nextToken.document.update({ \"img\": originalimg });\n\t\t\t\t//await nextToken.refresh();\n\t\t\t   \n\t\t\t} else { //no animations found\n\t\t\t\tui.notifications.warn(\"No matching images found with timecodes for \" + nextToken.name +\"!\");\n\t\t\t}\n\t\t} catch (err) { //ui catch\n\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t}\n\t\t//end of loop. next token\n\t\n}\n})();","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"furnace":{"runAsGM":false},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.VqXnUvIvny0s0Udr"}},"_id":"if5QbCdYM23dSX7T"}
{"name":"ParsedAnimation-KO","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/unconscious.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens.\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n//adjust this to match the filtered animations tied to character image of selected tokens\nlet searchstart = \"Idle\"\nlet searchanim = \"Death\"\nlet searchstatic = \"Dead\"\nlet timeoutoffset = 0\n//all other comments afterward are just descriptive for others to understand.\n//\n//simple function for delay timer.\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n\n//cycle through and set default image per token\nfor(let nextToken of canvas.tokens.controlled) {\n\ttry { //exception handling\n\t\t\t\n\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n\t\tif (!originalimg || originalimg === \"\") {\n\t\t\toriginalimg = nextToken.data.img; //backup current image for later.\n\t\t\tconsole.log(\"flag not set for originalimg. Setting now to: \" + originalimg);\n\t\t\tawait nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t}\n\t} catch (err) { //ui catch\n\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t}\n}\nif(canvas.tokens.controlled.length == 1){\n    //loop through all selected tokens.\n    for(let nextToken of canvas.tokens.controlled) {\n        (async () => {\n\t\t\ttry { //exception handling\n\t\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n    \t\t\t\n\t\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\t\tlet StaticArray = []; //predeclare array to load up.\n\t\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\t\tlet search1 = fname.search(searchanim);\n\t\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\t\tlet search3 = fname.search(searchstatic)\n\t\t\t\t\tif (search1 >= 0 && search2 >= 0) { //charname and search name must match to continue\n\t\t\n\t\t\t\t\t\tconsole.log(\"Image found: \" + fname);\n\t\t\t\t\t\tlet sstring = fname.split(\"_\"); //pull framecount\n\t\t\t\t\t\tlet framecount = sstring[sstring.length - 1].split(\"-\")[1]\n\t\t\t\t\t\tlet parsedtimeout = parseFloat( framecount.split(\".\")[0]) //parse framecount into number\n\t\t\t\t\t\tif (isNaN(parsedtimeout)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tconsole.log(\"could not parse animation time due to missing time code!\"); //failed to parse\n\t\t\t\t   \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tconsole.log(\"Expected animation time: \" + parsedtimeout * 33.33 + \"ms\");\n\t\t\t\t\t\t\tlet ParsedAnim = {  //build successfully found animation and add to list of valid animations\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tpath: imagefile,\n\t\t\t\t\t\t\t\ttimeout: (parsedtimeout * 33.33)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tAnimArray.push(ParsedAnim);\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t}else if (search3 >= 0 && search2 >= 0) {\n\t\t\t\t\t\tconsole.log(\"Static Image found: \" + fname);\n\t\t\t\t\t\tStaticArray.push(imagefile)\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (AnimArray.length > 1 && StaticArray.length > 0) { //multiple animations, pick one randomly\n\t\t\t\t\tconsole.log(\"Multiple matches found, selecting a random animation\");\n\t\t\t\t\tlet imageChoice = Math.floor(Math.random() * AnimArray.length);\n\t\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t\tlet finalimage = StaticArray[0] ;\n\t\t\t\t\t//console.log(image);\n\t\t\t\t\tconsole.log(\"Assigning randomized Animation Path: \" + image.path );\n\t\t\t\t\t\n\t\t\t\t\t//await nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t\t\t\tawait nextToken.document.update({ \"img\": image.path });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\t\tawait wait((image.timeout + timeoutoffset));\n\t\t\t\t\tconsole.log(\"Animation complete, Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t\t\n\t\t\t\t} else if (AnimArray.length == 1 && StaticArray.length > 0) { // single animation found, no randomization\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlet imageChoice = 0;\n\t\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t\tlet finalimage = StaticArray[0]\n\t\t\t\t\t//console.log(image);\n\t\t\t\t\tconsole.log(\"Single match found. Assigning Animation Path:\" + image.path );\n\t\t\t\t\t//await nextToken.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t\t\t\tawait nextToken.document.update({ \"img\": AnimArray[imageChoice].path })\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + (image.timeout + timeoutoffset) + \" ms\");\n\t\t\t\t\tawait wait((image.timeout + timeoutoffset));\n\t\t\t\t\tconsole.log(\"Animation complete, Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t} else if (AnimArray.length == 0 && StaticArray.length > 0) { // single animation found, no randomization\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlet finalimage = StaticArray[0]\n\t\t\t\t\t//console.log(image);\n\t\t\t\t\t//await nextToken.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t\t\t\tconsole.log(\"No Animation found, Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t} else { //no animation + static picture combo found\n\t\t\t\t\tconsole.log(\"No matching image combinations found for \" + nextToken.name +\", skipping.\");\n\t\t\t\t}\n\t\t\t} catch (err) { //ui catch\n\t\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t}\n\t\t\t//end of loop. next token\n\t\t})();\n    }\n}else {//multiple targets, using static only.\n     (async () => {\n                   for(let nextToken of canvas.tokens.controlled) {\n        \n\t\t\ttry { //exception handling\n\t\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n    \t\t\t\n\t\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\t\tlet StaticArray = []; //predeclare array to load up.\n\t\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\t\t//let search1 = fname.search(searchanim);\n\t\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\t\tlet search3 = fname.search(searchstatic)\n\t\t\t\t\tif (search3 >= 0 && search2 >= 0) {\n\t\t\t\t\t\tconsole.log(\"Static Image found: \" + fname);\n\t\t\t\t\t\tStaticArray.push(imagefile);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( StaticArray.length > 0) { // single animation found, no randomization\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tlet finalimage = StaticArray[0]\n\t\t\t\t\tconsole.log(\"Assigning new static Path: \" + finalimage );\n\t\t\t\t\tawait nextToken.document.update({ \"img\": finalimage });\n\t\t\t\t\t//nextToken.refresh();\n\t\t\t\t} else { //no animation + static picture combo found\n\t\t\t\t\tconsole.log(\"No matching image combinations found for \" + nextToken.name +\", skipping.\");\n\t\t\t\t}\n\t\t\t} catch (err) { //ui catch\n\t\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t}\n\t\t\t//end of loop. next token\n\t\t\n             }\n    })();\n}","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.wQsUFQoAkUgo5I25"}},"_id":"noK358QghvLb1TVJ"}
{"name":"Undo-KO","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/regen.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens.\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n\n//loop through all selected tokens.\nfor(let nextToken of canvas.tokens.controlled) {\n    try { //exception handling\n        let originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n    \tif (originalimg != null && originalimg != \"\") { \n    \t     console.log(\"Found backup image to revert to. Setting HP to 1(if zero) and Updating Image to: \" + originalimg)\n    \t    //nextToken.data.actorData.data.attributes.hp.value = 1 ;\n    \t    if (nextToken.document.actor.data.data.attributes.hp.value != null && nextToken.document.actor.data.data.attributes.hp.value == 0) {\n\t\t\t\tnextToken.document.actor.update({\"data.attributes.hp.value\" : 1}) //backup original image incase of undo.\n    \t    }\n\t\t\tnextToken.document.update({ \"img\": originalimg }) //backup original image incase of undo.\n       \n            nextToken.refresh();\n    \t} else { //no animations found\n    \t    ui.notifications.warn(\"No original image found for idle \" + nextToken.name +\"!\");\n    \t}\n    } catch (err) { //ui catch\n            ui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n            console.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n    }\n\t//end of loop. next token\n}","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.0oTX9YbTnJ1tTyqd"}},"_id":"p43PtMP9UhHD9ONe"}
{"name":"ParsedAnimation-Attack2","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/sword.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens. V8+ of foundry use only due to new API Controls\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n//adjust this to match the filtered animations tied to character image of selected tokens\nlet search = \"Attack2\"\n\n//all other comments afterward are just descriptive for others to understand.\n//\n//simple function for delay timer.\n\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n\n//loop through all selected tokens.\nfor(let nextToken of canvas.tokens.controlled) {\n\t\n\t(async () => {\n\t\ttry { //exception handling\n\t\t\t//let originalimg = nextToken.data.img; //backup current image for later.\n\t\t\t//await nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n        \tif (!originalimg || originalimg === \"\") {\n        \t\toriginalimg = nextToken.data.img; //backup current image for later.\n        \t\tconsole.log(\"flag not set for originalimg. Setting now to: \" + originalimg);\n        \t\tawait nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n        \t}\n        \t\n\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\tlet search1 = fname.search(search);\n\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\tif (search1 >= 0 && search2 >= 0) { //charname and search name must match to continue\n\t\n\t\t\t\t\tconsole.log(\"Image found: \" + fname);\n\t\t\t\t\tlet sstring = fname.split(\"_\"); //pull framecount\n\t\t\t\t\tlet framecount = sstring[sstring.length - 1].split(\"-\")[1]\n\t\t\t\t\tlet parsedtimeout = parseFloat( framecount.split(\".\")[0]) //parse framecount into number\n\t\t\t\t\tif (isNaN(parsedtimeout)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log(\"could not parse animation time due to missing time code!\"); //failed to parse\n\t\t\t   \n\t\t\t\t\t}\n\t\t\t\t\telse { \n\t\t\t\t\t\tconsole.log(\"Expected animation time: \" + parsedtimeout * 33.33 + \"ms\");\n\t\t\t\t\t\tlet ParsedAnim = {  //build successfully found animation and add to list of valid animations\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tpath: imagefile,\n\t\t\t\t\t\t\ttimeout: (parsedtimeout * 33.33)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tAnimArray.push(ParsedAnim);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (AnimArray.length > 1) { //multiple animations, pick one randomly\n\t\n\t\t\t\tconsole.log(\"Multiple matches found, selecting a random animation\");\n\t\t\t\tlet imageChoice = Math.floor(Math.random() * AnimArray.length);\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Assigning randomized Animation Path: \" + image.path );\n\t\t\t\tnextToken.document.update({ \"img\": image.path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\n\t\t\t} else if (AnimArray.length == 1) { // single animation found, no randomization\n\t\t\t\n\t\t\t\t\n\t\t\t\tlet imageChoice = 0;\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Single match found. Assigning Animation Path:\" + image.path );\n\t\t\t\t\n\t\t\t\tnextToken.document.update({ \"img\": AnimArray[imageChoice].path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\t\t   \n\t\t\t} else { //no animations found\n\t\t\t\tui.notifications.warn(\"No matching images found with timecodes for \" + nextToken.name +\"!\");\n\t\t\t}\n\t\t} catch (err) { //ui catch\n\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t}\n\t\t//end of loop. next token\n\t})();\n}","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"furnace":{"runAsGM":false},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.j4oDghbkR6L0Y7r5"}},"_id":"s9LrDxmhVQEctA6f"}
{"name":"ParsedAnimation-Attack4","type":"script","author":"nxH0r37ZrV193bd4","img":"icons/svg/sword.svg","scope":"global","command":"//written by Kelanel \n//For usage with VAM(Vivid adeventure maps) animated tokens. V8+ of foundry use only due to new API Controls\n//Expecting a specific filename layout to use for character matching, animation searches, and frame counts for timecodes\n//Example: VAM_MonkMMA_Attack2LegSweep_0122.webm\n// \"MonkMMA\" is considered the character name and only files with this after the first underscore will be used by macro matching the currently assigned filename\n// \"Attack2LegSweep\" is used by the search string below to filter what actions you like to select from. Be more specific to filter between specific files\n// \"0122\" is the numbered frame count at the end of the filename and must be after the last underscore. This is expect to be running at 30fps and will be multiplied as such.\n// All requirements must be filled above to work properly. The current image file will be updated with the animation for x time, then reverted to the original image.\n//This works best with MidiQOL's Macro on action to tie to specific actions of actors. Make one macro per search parameter, otherwise this macro can be used on multiple chars\n\n\n\n//adjust this to match the filtered animations tied to character image of selected tokens\nlet search = \"Attack4\"\n\n//all other comments afterward are just descriptive for others to understand.\n//\n//simple function for delay timer.\n\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n\n//loop through all selected tokens.\nfor(let nextToken of canvas.tokens.controlled) {\n\t\n\t(async () => {\n\t\ttry { //exception handling\n\t\t\t//let originalimg = nextToken.data.img; //backup current image for later.\n\t\t\t//await nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n\t\t\tlet originalimg = nextToken.document.getFlag(\"world\", \"originalimg\"); //backup current image for later.\n        \tif (!originalimg || originalimg === \"\") {\n        \t\toriginalimg = nextToken.data.img; //backup current image for later.\n        \t\tconsole.log(\"flag not set for originalimg. Setting now to: \" + originalimg);\n        \t\tawait nextToken.document.setFlag(\"world\", \"originalimg\", originalimg ); //backup original image incase of undo.\n        \t}\n        \t\n\t\t\tlet imgpath = originalimg.split(\"/\");   //splitting to breakdown to just filename\n\t\t\tlet imgname = imgpath[imgpath.length -1].split(\"_\"); //final breakdown to use name for parsing parts.\n\t\t\tlet charname = imgname[1]; //parsing Charactername\n\t\t\tconsole.log(\"Charactername found: \" + charname);\n\t\t\tlet AnimArray = []; //predeclare array to load up.\n\t\t\tlet response = await FilePicker.browse(\"data\", originalimg); //query directory of current imagefile\n\t\t\tfor(let imagefile of response.files) {  //parse files\n\t\t\t\tlet fpath = imagefile.split(\"/\");\n\t\t\t\tlet fname = fpath[fpath.length - 1]; //scrape file name\n\t\t\t\tlet search1 = fname.search(search);\n\t\t\t\tlet search2 = fname.search(charname);\n\t\t\t\tif (search1 >= 0 && search2 >= 0) { //charname and search name must match to continue\n\t\n\t\t\t\t\tconsole.log(\"Image found: \" + fname);\n\t\t\t\t\tlet sstring = fname.split(\"_\"); //pull framecount\n\t\t\t\t\tlet framecount = sstring[sstring.length - 1].split(\"-\")[1]\n\t\t\t\t\tlet parsedtimeout = parseFloat( framecount.split(\".\")[0]) //parse framecount into number\n\t\t\t\t\tif (isNaN(parsedtimeout)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log(\"could not parse animation time due to missing time code!\"); //failed to parse\n\t\t\t   \n\t\t\t\t\t}\n\t\t\t\t\telse { \n\t\t\t\t\t\tconsole.log(\"Expected animation time: \" + parsedtimeout * 33.33 + \"ms\");\n\t\t\t\t\t\tlet ParsedAnim = {  //build successfully found animation and add to list of valid animations\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tpath: imagefile,\n\t\t\t\t\t\t\ttimeout: (parsedtimeout * 33.33)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tAnimArray.push(ParsedAnim);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif (AnimArray.length > 1) { //multiple animations, pick one randomly\n\t\n\t\t\t\tconsole.log(\"Multiple matches found, selecting a random animation\");\n\t\t\t\tlet imageChoice = Math.floor(Math.random() * AnimArray.length);\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Assigning randomized Animation Path: \" + image.path );\n\t\t\t\tnextToken.document.update({ \"img\": image.path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\n\t\t\t} else if (AnimArray.length == 1) { // single animation found, no randomization\n\t\t\t\n\t\t\t\t\n\t\t\t\tlet imageChoice = 0;\n\t\t\t\tlet image = AnimArray[imageChoice];\n\t\t\t\t//console.log(image);\n\t\t\t\tconsole.log(\"Single match found. Assigning Animation Path:\" + image.path );\n\t\t\t\t\n\t\t\t\tnextToken.document.update({ \"img\": AnimArray[imageChoice].path })\n\t\t\t\tnextToken.refresh();\n\t\t\t\tconsole.log(\"Animation Assigned.. Waiting \" + image.timeout + \" ms\");\n\t\t\t\tawait wait(image.timeout);\n\t\t\t\tconsole.log(\"Animation complete, Assigning original Animation Path: \" + originalimg );\n\t\t\t\tnextToken.document.update({ \"img\": originalimg });\n\t\t\t\tnextToken.refresh();\n\t\t\t   \n\t\t\t} else { //no animations found\n\t\t\t\tui.notifications.warn(\"No matching images found with timecodes for \" + nextToken.name +\"!\");\n\t\t\t}\n\t\t} catch (err) { //ui catch\n\t\t\t\tui.notifications.error(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t\t\tconsole.log(`Error processing ${nextToken.name}, ERROR: ${err}`);\n\t\t}\n\t\t//end of loop. next token\n\t})();\n}","folder":null,"sort":0,"permission":{"default":0,"nxH0r37ZrV193bd4":3},"flags":{"furnace":{"runAsGM":false},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.BFGpcq0nsoOqQXGi"}},"_id":"vpNQKqInbGIAPMpR"}
